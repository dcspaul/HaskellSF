{\rtf1\ansi\ansicpg1252\cocoartf1265\cocoasubrtf190
{\fonttbl\f0\fnil\fcharset0 ChalkboardSE-Regular;}
{\colortbl;\red255\green255\blue255;}
\paperw11900\paperh16840\margl1440\margr1440\vieww14040\viewh15940\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural

\f0\b\fs28 \cf0 Links
\b0 \
\
A good introduction to Parsec: {\field{\*\fldinst{HYPERLINK "http://book.realworldhaskell.org/read/using-parsec.html"}}{\fldrslt Chapter\'a016.\'a0Using Parsec}}\
Another intro  including the expression parser: {\field{\*\fldinst{HYPERLINK "http://www.haskell.org/haskellwiki/Parsing_expressions_and_statements"}}{\fldrslt Parsing expressions and statements - HaskellWiki}}\
Slightly different stuff on parsing with monads: {\field{\*\fldinst{HYPERLINK "http://en.wikibooks.org/wiki/Haskell/Practical_monads"}}{\fldrslt Haskell/Practical monads - Wikibooks}}\
\
Parsec combinator reference: {\field{\*\fldinst{HYPERLINK "http://hackage.haskell.org/package/parsec-3.0.0/docs/Text-Parsec-Combinator.html"}}{\fldrslt Text.Parsec.Combinator}}\
Parsec token reference: {\field{\*\fldinst{HYPERLINK "http://hackage.haskell.org/package/parsec-3.0.1/docs/Text-ParserCombinators-Parsec-Token.html"}}{\fldrslt Text.ParserCombinators.Parsec.Token}}\
Some more combinators (non-standard?): {\field{\*\fldinst{HYPERLINK "http://cvs.haskell.org/Hugs/pages/libraries/base/Text-ParserCombinators-ReadP.html"}}{\fldrslt Text.ParserCombinators.ReadP}}\
\

\b Monads\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural

\b0 \cf0 \
some monadic thing >>= f\
f accepts the inside of the monad and must return a monadic value\
Just "me" >>= \\s -> Just (s ++ "!")\
if the LHS is outside the Monad, it just gets passed through\
Nothing >>= \\s -> Just (s ++ "!")\
\
some monadic thing >> blob\
returns blob if the argument is in the monad\
Just "me" >> Just "yeah"\
if the LHS is outside the Monad, it just gets passed through\
Nothing >> Just "never happens"\
\
Inside a "do" ...\
<- extracts the inside from a monad: <- Just "me" is "me"\
return converts the other way: return "me" is Just "me"\
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural

\b \cf0 Monadic Parsers\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural

\b0 \cf0 \
Based on this (good) paper: {\field{\*\fldinst{HYPERLINK "http://www.cs.nott.ac.uk/~gmh/pearl.pdf"}}{\fldrslt Monadic Parsing in Haskell}}\
\
A parser is a function: newtype Parser a = Parser (String -> [(a,String)])\
- takes a string\
- returns a list of ( object, rest ) pairs\
- the "object" is the parsed object\
- the "rest" is the remaining string\
- the "list" is because there may have been more than one possibility\
\
You need different types of parsers for different object types:\
- e.g. a "Parser Char" might chew off the first character and return [ (head,tail) ]\
\
To make this into a monad ...\
- the inside of the Monad has type "a"\
- "return SOMETHING" just creates a parser which returns [(SOMETHING, string)] when applied to a string\
- remember that a parser is a function over strings\
\
>>=\
- given a parser for A\
- and a function which takes an A and makes a parser for B\
- return a parser for B\
this is tricky because we need to handle the possibilities of "lists" of results\
which involves some comprehension & concatenation. But basically ...\
- applying the parser for A which returns an A (and the remaining string)\
- applying the function to the A to get a parser for B\
- applying the parser for B to the remaining string\
\
The choice operator (++) ...\
- concatenates the lists of results from two parsers\
- this means that the results are tried in order\
- since the evaluation is lazy, this means that we only evaluate what we need!\
- zero is the left and right zero, and ++ is associative\
\
The deterministic choice operator (+++) ...\
- this is like (++) but only returns the first result (if any)\
- this prevents explosion when there are lots of alternatives\
\
sat ...\
- the parser "sat" takes a boolean predicate\
- and returns a char iff it satisifes the predicate\
- this can be used to create (eg) a digit parser etc\
\
combinators ...\
- eg. string, many p, many1 p, p sepBy `sep`,  p sepBy1 `sep`, cain1  op a, chainl1 p op a \
\
\
\
\
\
\
}